<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 手势交互粒子系统</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* 摄像头预览 (可选，方便调试) */
        #video-input {
            position: absolute; bottom: 20px; left: 20px; width: 160px; height: 120px;
            border-radius: 10px; border: 2px solid rgba(255,255,255,0.2); z-index: 2;
            transform: scaleX(-1); /* 镜像翻转 */
            opacity: 0.7;
        }

        /* 加载提示 */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; pointer-events: none; z-index: 10;
            text-align: center;
        }

        /* 全屏按钮 */
        #fs-btn {
            position: absolute; bottom: 20px; right: 20px; z-index: 100;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2);
            color: white; padding: 10px 20px; border-radius: 20px; cursor: pointer;
            backdrop-filter: blur(5px); transition: 0.3s;
        }
        #fs-btn:hover { background: rgba(255, 255, 255, 0.3); }

        /* 手势提示 */
        #gesture-hint {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.5); font-size: 14px; pointer-events: none; z-index: 5;
        }
    </style>
</head>
<body>

    <div id="loader">正在加载视觉模型...<br><span style="font-size:14px; opacity:0.7">请允许摄像头权限</span></div>
    <div id="gesture-hint">食指与拇指张开：扩散/放大 | 捏合：凝聚/缩小</div>
    
    <video id="video-input" playsinline></video>
    
    <div id="canvas-container"></div>
    <button id="fs-btn">进入全屏</button>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js",
                "@mediapipe/drawing_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';
        import { Hands, HAND_CONNECTIONS } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js';
        import { Camera } from 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js';

        // --- 配置项 ---
        const PARTICLE_COUNT = 15000;
        const config = {
            shape: '爱心',
            color: '#00ffff',
            particleSize: 0.15,
            handInfluence: 1.0, // 手势权重
            autoRotate: true
        };

        // --- 全局变量 ---
        let scene, camera, renderer, particles, geometry, material;
        let originalPositions = []; // 存储目标形状的坐标
        let currentPositions = [];  // 当前粒子坐标
        let targetScale = 1;        // 手势控制的缩放
        let isHandDetected = false;
        
        const videoElement = document.getElementById('video-input');
        const loader = document.getElementById('loader');

        // --- 1. Three.js 初始化 ---
        function initThree() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 20;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // 控制器
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // 粒子系统
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 50; // 初始随机分布
                currentPositions.push(positions[i]);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            material = new THREE.PointsMaterial({
                color: config.color,
                size: config.particleSize,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 初始化默认形状
            updateShape('爱心');

            // 窗口自适应
            window.addEventListener('resize', onWindowResize);
        }

        // --- 2. 形状生成算法 ---
        function getShapeData(type) {
            const positions = [];
            const scale = 8; // 基础大小

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;
                // 简单的归一化变量
                const u = Math.random();
                const v = Math.random();
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                if (type === '爱心') {
                    // 3D Heart formula
                    const t = Math.PI - 2 * Math.PI * u; // -PI to PI
                    // 使用稍微复杂的3D心形公式
                    // r = 1-cos(t), etc. 简化版:
                    // x = 16sin^3(t)
                    // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                    // z = random depth profile
                    
                    // 这里使用一个体积心形分布
                    const r = Math.pow(u, 1/3); // 均匀分布
                    const th = theta;
                    const ph = Math.acos(2 * v - 1);
                    
                    // 这是一个简化的心形点云生成逻辑
                    // 让我们用一个更确定的参数方程
                    x = 16 * Math.pow(Math.sin(th), 3);
                    y = 13 * Math.cos(th) - 5 * Math.cos(2*th) - 2 * Math.cos(3*th) - Math.cos(4*th);
                    z = (Math.random() - 0.5) * 10; 
                    
                    // 压缩一下z轴并缩放
                    x *= 0.5; y *= 0.5;
                } 
                else if (type === '花朵') {
                    // Rose curve 3D projection
                    const k = 5; // 花瓣数
                    const r = Math.cos(k * theta);
                    x = r * Math.cos(theta) * 10;
                    y = r * Math.sin(theta) * 10;
                    z = (Math.random() - 0.5) * 5 + Math.sin(r*5)*2;
                }
                else if (type === '王星') { // 五角星/复杂星体
                    const r = 8;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    
                    // 把它压成星形 spikes
                    const spike = Math.abs(Math.sin(theta * 5) * Math.sin(phi * 5)) + 0.5;
                    x *= spike; y *= spike; z *= spike;
                }
                else if (type === '佛像') {
                    // 由于无法加载模型，我们用数学方法构建一个抽象的"打坐的人"
                    // 头部(球体) + 身体(圆锥/椭圆)
                    const section = Math.random();
                    if(section > 0.8) { 
                        // 头
                         const r = 2.5;
                         x = r * Math.sin(phi) * Math.cos(theta);
                         y = r * Math.sin(phi) * Math.sin(theta) + 6; // 向上偏移
                         z = r * Math.cos(phi);
                    } else {
                        // 身体 (底部宽顶部窄)
                        const h = (Math.random() - 0.5) * 8; // -4 to 4
                        const rBody = (1 - (y/10)) * 5; // 简单的锥体近似
                         // 身体采用更像是盘腿的形状 (Torus knot 近似或椭球)
                         // 使用椭球模拟身体
                         const a = 6, b = 5, c = 4;
                         x = a * Math.sin(phi) * Math.cos(theta);
                         y = b * Math.sin(phi) * Math.sin(theta) - 2;
                         z = c * Math.cos(phi);
                         // 切掉下半部分或压扁
                         if(y < -2) y *= 0.2;
                    }
                }
                else if (type === '烟花') {
                    // 球体爆发
                    const r = 10 * Math.cbrt(Math.random()); // 内部填充
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }

                positions.push(x, y, z);
            }
            return positions;
        }

        function updateShape(type) {
            originalPositions = getShapeData(type);
        }

        // --- 3. UI 初始化 ---
        function initGUI() {
            const gui = new GUI({ title: '控制面板' });
            
            gui.add(config, 'shape', ['爱心', '花朵', '王星', '佛像', '烟花'])
               .name('模型形状')
               .onChange(val => updateShape(val));
            
            gui.addColor(config, 'color')
               .name('粒子颜色')
               .onChange(val => material.color.set(val));

            gui.add(config, 'particleSize', 0.01, 0.5)
               .name('粒子大小')
               .onChange(val => material.size = val);

            gui.add(config, 'autoRotate').name('自动旋转');
        }

        // --- 4. MediaPipe 手势检测 ---
        async function initHandTracking() {
            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);

            const cameraObj = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });

            cameraObj.start()
                .then(() => {
                    loader.style.display = 'none';
                    console.log("Camera started");
                })
                .catch(err => {
                    loader.innerHTML = "摄像头启动失败，请检查权限。<br>请使用HTTPS或Localhost。";
                });
        }

        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // 获取拇指指尖(4)和食指指尖(8)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];

                // 计算距离 (简单的欧几里得距离，主要看x/y)
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // 映射逻辑：
                // 距离 0.02 (捏合) -> Scale 0.1 (凝聚)
                // 距离 0.2 (张开) -> Scale 2.0 (扩散)
                // 这一步需要根据实际摄像头画面微调
                let factor = (distance - 0.02) * 8; 
                factor = Math.max(0.1, Math.min(factor, 2.5)); // 限制范围
                
                // 平滑过渡
                targetScale += (factor - targetScale) * 0.1;

            } else {
                isHandDetected = false;
                // 手移开后慢慢恢复原状
                targetScale += (1.0 - targetScale) * 0.05;
            }
        }

        // --- 5. 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            const positions = particles.geometry.attributes.position.array;
            
            // 简单的插值速度
            const lerpSpeed = 0.05;

            // 自动旋转
            if(config.autoRotate && !isHandDetected) {
                particles.rotation.y += 0.002;
            }

            // 更新粒子位置
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // 目标基础位置
                let tx = originalPositions[ix];
                let ty = originalPositions[iy];
                let tz = originalPositions[iz];

                // 应用手势缩放/扩散
                // 逻辑：如果是烟花，可能想让它炸开；这里做通用的缩放扩散
                tx *= targetScale;
                ty *= targetScale;
                tz *= targetScale;

                // 如果手势是捏合（scale很小），加上一点随机抖动模拟能量聚集
                if(targetScale < 0.4) {
                    tx += (Math.random()-0.5) * 0.5;
                    ty += (Math.random()-0.5) * 0.5;
                    tz += (Math.random()-0.5) * 0.5;
                }

                // 插值更新
                positions[ix] += (tx - positions[ix]) * lerpSpeed;
                positions[iy] += (ty - positions[iy]) * lerpSpeed;
                positions[iz] += (tz - positions[iz]) * lerpSpeed;
            }

            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 全屏逻辑
        document.getElementById('fs-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });

        // --- 启动 ---
        initThree();
        initGUI();
        initHandTracking(); // 异步启动摄像头
        animate();

    </script>
</body>
</html>
